Criando o projeto: 
    ng new gatitobook --strict

O parm strict força tipagem estática (tanto no TypeScript quanto no Angular).

Instalação do Bootstrap e do Font-Awesome:
    npm install bootstrap font-awesome

Mude o arquivo angular.json e inclua os CSS do Font-Awesome e do Bootstrap:
    Busque em projects-> gatitobook -> architect -> build -> options -> styles.

No angular.json, o parâmetro cli -> analytics = false é pra evitar envio de 
dados para o Google. Isso é colocado

Comando para criar um módulo com roteamento:
    ng generate module home --routing --dry-run
    ou
    ng generate module home --routing -d

    Onde:
        * routing significa que o desejamos usar roteamento, e
        * dry-run significa que não queremos que os arquivos sejam gerados (?).
Para criar de fato o módulo, retire o parâmetro dry-run


A comunidade Angular tem vários tipos de módulo: o componente home que criamos
é classificado como um feature module (módulo de funcionalidade).

O cli do Angular permite abreviação dos comandos. Então, os comandos a seguir 
são idênticos:
    ng generate component home
    ng g c home

A criação do componente home usando o cli auto-atualiza o home.module.ts.
Talvez porque os nomes do módulo e do componentes são iguais.

Os arquivos estáticos ficam dentro da pasta assets. Essa pasta é setada por 
padrão no arquivo angular.json, e a referência pode ser modificada.
    Busque em projects-> gatitobook -> architect -> build -> options -> assets.

Alternativa para rodar a aplicação:
    ng s --o
    ou
    ng serve --open

O parâmetro loadChildren dentro de um Route recebe um módulo. No exemplo, o
módulo é obtido por meio de função que carrega as rotas de um outro módulo.
Isso é interessante porque a função não carrega os módulos enquanto não for
chamada (lazy loading).

Perceba que as rotas de AppModule e HomeModule são diferentes. AppModule mantém
o lazy loading, enquanto o HomeModule carrega de fato os componentes.

A tag router-outlet serve como container para os componentes, que são 
exibidos de acordo com a sua rota.

Criando o componente de login dentro do módulo home: 
    ng generate component home/login
    ou
    ng g c home/login

Não confunda: as rotas ficam guardadas no módulo de roteamento, não no
módulo principal. Ex.: HomeRoutingModule tem as rotas; HomeModule as importa.

O parâmetro children nas rotas serve para inclusão de sub-rotas. No exemplo, 
a sub rota para LoginComponent corresponde a uma string vazia. Para cada 
componente com rotas children devemos usar uma tag router-outlet no HTML.

Criando o módulo de autenticação:
    ng generate module autenticacao
    ou
    ng g m autenticacao

Criando o serviço de autenticação no módulo de autenticação:
    ng generate service autenticacao/autenticacao
    ou
    ng g s autenticacao/autenticacao

O objeto httpClient (em '@angular/common/http') contém métodos para as 
mensagens HTTP (POST, GET etc). Cada método desses recebe dois parâmetros:
a URL e o corpo da requisição (do tipo any, mas aqui usamos um dicionário).

O Angular trata formulário de uma das duas maneiras: forms template-driven, e 
forms reativos. O módulo FormsModule é usado para criar formulários baseados
em template.

LoginComponent.ts foi modificado para acrescentar um método e dois modelos que
vão interagir com o HTML do componente.

O curso não explicou o desenvolvimento da API, mas o código fonte está 
disponível na pasta api (fora de gatitobook). Para rodar o webservice, 
execute os comandos a partir da pasta api:
    npm install (para baixar as dependências)
    npm start   (para executar a API na porta 3000. Informações de usuário 
                vão estar aparecendo no log da linha de comando.)

De acordo com a documentação do HttpClientModule, ele: 
    Configures the dependency injector for HttpClient with supporting services
    for XSRF. Automatically imported by HttpClientModule.

Por conta dessas configurações de injeção de dependência, precisamos importar
o módulo HttpClientModule no arquivo ts de AppModule.

O serviço de autenticação não teve mudanças, só teve no nome do método.

LoginComponent apenas contém a lógica de apresentação dos resultados da 
interação com o serviço de autenticação.

Criação do módulo de animais + roteamento:
    ng generate module animais --routing
    ou
    ng g m animais --routing

Criação de ListaAnimaisComponent no módulo animais:
    ng generate component animais/lista-animais
    ou
    ng g c animais/lista-animais

Mais uma vez: o módulo é atualizado pelo cli do Angular depois que ele é 
referenciado durante a criação do componente (ListaAnimaisComponent é 
referenciado em AnimaisModule, por causa do prefixo correspondente ao nome
do módulo em animais/lista-animais).

O método de login em LoginComponent vai usar um objeto do tipo Router, para
redirecionar as requisições para as rotas da aplicação.

Cada novo módulo precisa ser importado em AppRoutingModule, para centralizar
as referências para as rotas espalhadas pelos outros módulos.

O código de ListaAnimaisComponent não sofreu alterações depois de gerado.

Criação do módulo de mensagem dentro do diretório componentes:
    ng generate module componentes/mensagem
    ou
    ng g m componentes/mensagem

MensagemModule é criado dentro da subpasta componentes 
(veja o prefixo componentes/mensagem na criação).

Idem para a criação do componente:
    ng generate component componentes/mensagem
    ou
    ng g c componentes/mensagem

De novo: ao usar o cli do Angular para criar um componente dentro do diretório
de um módulo, o .ts do módulo é atualizado com a declaração do componente
recém criado.

Interpolação de conteúdo: usar {{ variavel }} para expor conteúdo dos .ts
para os arquivos .html.

Em https://angular.io/guide/interpolation :
Interpolation refers to embedding expressions into marked up text. By default,
interpolation uses the double curly braces {{ and }} as delimiters.


O decorator Input() - lembre-se dos parênteses - serve para configurar a 
variável como um objeto modificável pelo componente pai (o mesmo que vai 
conter o componente com a anotação Input()).

Lembrando: um componente de um módulo só fica visível se o módulo o exportar.
Veja o parâmetro exports dentro da anotação @NgModule em MensagemModule.

NgModules: 
    declarations é um array de COMPONENTES;
    imports é um array de MÓDULOS que ficam visíveis para os templates.

MensagemModule está sendo importado e com ele os seus componentes. Note que 
o MensagemComponent não foi importado em HomeModule, mas ainda assim o template
LoginComponent consegue inserir o MensagemComponent.

Uma propriedade com qualquer nome precedido de cerquilha serve para criar uma 
referência para o Angular. Essa propriedade é tipada conforme o valor que você
atribuir em seguida. No exemplo, o input é nomeado como campoUsuario e 
representa um ngModel: 
    <input
      ...
      [(ngModel)]="variavel_no_componente"
      ...
      #campoComponente="ngModel"
      ...
    />

Essa referência #campoComponente pode ser usada para outras diretivas, como
a ngIf: 
    <app-filho *ngIf="campoComponente.invalid" msg="Inválido."></app-filho>
    // O segundo dá erro de compilação.
    <app-filho *ngIf="campoComponente.value !== senha" msg="Inválido.">
    </app-filho>

Como personalizar mais a validação? Basta inserir critérios de validação 
do próprio HTML para ver se o campo é inválido:

    <input
      ...
      [(ngModel)]="variavel_no_componente"
      #senha="ngModel"
      minlength="3"
      ...
    />
    <app-filho *ngIf="senha.invalid" msg="Deve ter mais que 2 caracteres.">
    </app-filho>

Há um outro booleano resultante do foco no campo. Ele é chamado "touched":
    <app-mensagem 
        *ngIf="campoSenha.invalid && campoSenha.touched" 
        mensagem="Senha obrigatória"
    ></app-mensagem>

Para desabilitar um botão, use a propriedade disabled mais o teste:
    <form #loginForm="ngForm">
        ...
        <button [disabled]="loginForm.invalid">Login</button>
    </form>

Note que o botão só vai ser habilitado quando o formulário estiver válido.
